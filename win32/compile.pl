#!perl 
use strict;
use warnings;
use File::Basename;
use File::Copy;
use File::Path;

my $name = shift || 'PerlLog';

# compile the message text files
system("mc.exe -d $name.mc");
system("rc $name.rc");

# uuencode the resource file
open(my $rsrc, '<', "$name.RES")
    or die "fatal: Can't read resource file '$name.RES': $!";
my $uudata = pack "u", do { local $/; <$rsrc> };
close($rsrc);
open(my $uufh, '>', "$name\_RES.uu")
    or die "fatal: Can't write file '$name\_RES.uu': $!";
print $uufh $uudata;
close($uufh);

# parse the generated header to extract the constants
open(my $header, '<', "$name.h")
    or die "fatal: Can't read header file '$name.h': $!";
my %vals;    
my $max = 0;

while (<$header>) {
    if (/^#define\s+(\w+)\s+(\d+)$/ || /^#define\s+(\w+)\s+\(\(DWORD\)(\d+)L\)/) {
        $vals{$1} = $2;
        if (substr($1, 0, 1) eq 'C') {
            $max = $2 if $max < $2;
        }
    }
}

close($header);

my ($hash, $f2c, %fac);

for my $name (sort { substr($a,0,1) cmp substr($b,0,1) || $vals{$a} <=> $vals{$b} } keys %vals) {
    $hash .= "    $name => $vals{$name},\n" ;
    if ($name =~ /^CAT_(\w+)$/) {
        $fac{$1} = $vals{$name};
    }
}

for my $name (sort {$fac{$a} <=> $fac{$b}} keys %fac) {
    $f2c .= "    Sys::Syslog::LOG_$name() => '$name',\n";
}    

# write the Sys::Syslog::Win32 module
open my $out, '>', "Win32.pm" or die "fatal: Can't write Win32.pm: $!";
my $template = join '', <DATA>;
$template =~ s/__CONSTANT__/$hash/;
$template =~ s/__F2C__/$f2c/;
$max = sprintf "0x%08x", $max;
$template =~ s/__MAX__/'$max'/g;
$template =~ s/__TIME__/localtime()/ge;
print $out $template;
close $out;

my $libpath = File::Spec->catdir(File::Spec->updir, qw(lib Sys Syslog));
mkpath $libpath
    or die "fatal: Can't create lib directory '$libpath': $!"
    if !-d $libpath;
copy "Win32.pm", File::Spec->catfile($libpath, "Win32.pm")
    or die "fatal: Can't copy file 'Win32.pm' into directory '$libpath': $!";

__END__
package Sys::Syslog::Win32;
use strict;
use warnings;
use File::Spec;

# === WARNING === WARNING === WARNING === WARNING === WARNING === WARNING ===
#
# This file was generated by Sys-Syslog/win32/compile.pl at __TIME__
# Any changes being made here will be lost the next time Sys::Syslog 
# is installed. 
#
# Do NOT USE THIS MODULE DIRECTLY: this is a utility module for Sys::Syslog.
# It may change at any time to fit the needs of Sys::Syslog therefore no 
# warranty is made WRT to its API. You Have Been Warned.
#
# === WARNING === WARNING === WARNING === WARNING === WARNING === WARNING ===

our $Source;
my $logger;
my $Registry;

use Win32::EventLog;
use Win32::TieRegistry 0.20 (
    TiedRef     => \$Registry,
    Delimiter   => "/",
    ArrayValues => 1,
    SplitMultis => 1,
    AllowLoad   => 1,
    qw(
        REG_SZ
        REG_EXPAND_SZ
        REG_DWORD
        REG_BINARY
        REG_MULTI_SZ
        KEY_READ
        KEY_WRITE
        KEY_ALL_ACCESS
    ),
);    

my %const = (
__CONSTANT__
);

my %id2name = (
__F2C__
);

my @priority2eventtype = (
    EVENTLOG_ERROR_TYPE(),       # LOG_EMERG
    EVENTLOG_ERROR_TYPE(),       # LOG_ALERT
    EVENTLOG_ERROR_TYPE(),       # LOG_CRIT
    EVENTLOG_ERROR_TYPE(),       # LOG_ERR
    EVENTLOG_WARNING_TYPE(),     # LOG_WARNING
    EVENTLOG_WARNING_TYPE(),     # LOG_NOTICE
    EVENTLOG_INFORMATION_TYPE(), # LOG_INFO
    EVENTLOG_INFORMATION_TYPE(), # LOG_DEBUG
);


# _install()
# --------
# Used to set up a connection to the eventlog.
# 
sub _install {
    return $logger if $logger;

    # can't just use basename($0) here because Win32 path often are a 
    # a mix of / and \, and File::Basename::fileparse() can't handle that, 
    # while File::Spec::splitpath() can.. Go figure..
    my (undef, undef, $basename) = File::Spec->splitpath($0);
    ($Source) ||= $basename;

    #$Registry->Delimiter("/"); # is this needed?
    my $root = 'LMachine/SYSTEM/CurrentControlSet/Services/Eventlog/Application/';
    my $dll  = 'Sys/Syslog/Syslog.dll';
    my ($file) = grep { -e $_ }  map { ("$_/$dll" => "$_/auto/$dll") }  @INC;
    $file =~ s![\\/]+!\\!g;     # must be backslashes!
    die "No Dll found!" if !$file;

    if (!$Registry->{$root.$Source}) {
        $Registry->{$root.$Source} = {
            '/EventMessageFile'    => [ $file, REG_EXPAND_SZ ],
            '/CategoryMessageFile' => [ $file, REG_EXPAND_SZ ],
            '/CategoryCount'       => [ __MAX__, REG_DWORD ],
            #'/TypesSupported'      => [ __MAX__, REG_DWORD ],
        };

        if ($Sys::SysLog::DEBUG) {
            warn "Configured eventlog to use $dll for $Source\n";
        }
    }

    Carp::confess("Registry has the wrong value for '$Source', possibly mismatched dll!")
        if $Registry->{$root.$Source.'/CategoryMessageFile'}[0] 
        ne $file;

    my $host=""; # we really should do something useful with this
                 # but we set it to "" to prevent Win32::EventLog from warning..

    $logger= Win32::EventLog->new($Source, $host) 
        or Carp::confess("Failed to connect to the '$Source' event log");

    return $logger;
}


# _syslog_send()
# ------------
# Used to convert syslog messages into eventlog messages
# 
sub _syslog_send {
    my ($buf, $numpri, $numfac) = @_;
    my $name = $id2name{$numfac};

    my $opts = {
        EventType   => $priority2eventtype[$numpri], 
        EventID     => $const{"MSG_$name"},
        Category    => $const{"CAT_$name"}, 
        Strings     => "$buf\0", 
        Data        => "",
    };

    if ($Sys::Syslog::DEBUG) {
        require Data::Dumper;
        warn Data::Dumper->Dump([$name,$opts], [qw(name opts)]);
    }

    return $logger->Report($opts);
}


=head1 NAME

Sys::Syslog::Win32 - Win32 support for Sys::Syslog

=head1 DESCRIPTION

...

=head1 AUTHORS

...

=head1 COPYRIGHT

...

=cut




1;

